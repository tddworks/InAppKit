//
//  PurchaseOptionCard.swift
//  InAppKit
//
//  Purchase option card component for paywall - displays pricing and billing info
//

import SwiftUI
import StoreKit

// MARK: - Styling Constants

private enum CardStyle {
    static let cornerRadius: CGFloat = 14
    static let horizontalPadding: CGFloat = 20
    static let verticalPadding: CGFloat = 16
    static let contentSpacing: CGFloat = 16
    static let contentVerticalSpacing: CGFloat = 4
    static let featuresSpacing: CGFloat = 2
    static let featuresTopPadding: CGFloat = 2

    static let selectionIndicatorSize: CGFloat = 20
    static let selectionIndicatorFillSize: CGFloat = 10
    static let selectionIndicatorStroke: CGFloat = 2
    static let selectedStrokeWidth: CGFloat = 2
    static let unselectedStrokeWidth: CGFloat = 1

    static let selectedScale: CGFloat = 1.02
    static let animationDuration: Double = 0.15

    // Font sizes
    static let titleFontSize: CGFloat = 16
    static let descriptionFontSize: CGFloat = 13
    static let priceFontSize: CGFloat = 18
    static let billingPeriodFontSize: CGFloat = 12
    static let badgeFontSize: CGFloat = 10
    static let savingsFontSize: CGFloat = 10
    static let featureFontSize: CGFloat = 11

    // Badge styling
    static let badgeHorizontalPadding: CGFloat = 8
    static let badgeVerticalPadding: CGFloat = 2
}

struct PurchaseOptionCard: View {
    let product: Product
    let isSelected: Bool
    let onSelect: () -> Void

    // Optional marketing enhancements
    let badge: String?
    let badgeColor: Color?
    let features: [String]?
    let savings: String?

    init(
        product: Product,
        isSelected: Bool,
        onSelect: @escaping () -> Void,
        badge: String? = nil,
        badgeColor: Color? = nil,
        features: [String]? = nil,
        savings: String? = nil
    ) {
        self.product = product
        self.isSelected = isSelected
        self.onSelect = onSelect
        self.badge = badge
        self.badgeColor = badgeColor
        self.features = features
        self.savings = savings
    }
    
    private var productDescription: String {
        // Use user-defined description from StoreKit if available
        if !product.description.isEmpty && product.description != product.displayName {
            return product.description
        }

        // Fallback to auto-generated description (without intro offer info)
        return autoGeneratedDescription
    }

    private var autoGeneratedDescription: String {
        switch product.type {
        case .autoRenewable:
            if let subscription = product.subscription {
                // Just show subscription period (intro offers shown separately)
                let period = subscription.subscriptionPeriod
                return "\(periodText(period, style: .billing)) subscription"
            }
            return "purchase.subscription.description".localized(fallback: "Subscription • Auto-renewable")
        case .nonConsumable:
            return "purchase.lifetime.description".localized(fallback: "One-time purchase • Lifetime access")
        case .consumable:
            return "purchase.consumable.description".localized(fallback: "Consumable purchase")
        default:
            return "purchase.unknown.description".localized(fallback: "In-app purchase")
        }
    }

    private var introductoryOfferDescription: String? {
        guard let subscription = product.subscription,
              let intro = subscription.introductoryOffer else {
            return nil
        }

        let period = periodText(intro.period, style: .descriptive)
        let periodCount = intro.periodCount

        switch intro.paymentMode {
        case .freeTrial:
            // e.g., "7 days free trial"
            return "purchase.intro.free_trial".localized("\(period)", fallback: "\(period) free trial")
        case .payAsYouGo:
            // e.g., "$0.99 for first 3 months" or "$0.99/month for 3 months"
            if periodCount > 1 {
                return "purchase.intro.pay_as_you_go_multiple".localized("\(intro.displayPrice)", "\(periodCount)", "\(period)", fallback: "\(intro.displayPrice) for \(periodCount) \(period)s")
            } else {
                return "purchase.intro.pay_as_you_go_single".localized("\(intro.displayPrice)", "\(period)", fallback: "\(intro.displayPrice) for first \(period)")
            }
        case .payUpFront:
            // e.g., "$2.99 for first month"
            if periodCount > 1 {
                return "purchase.intro.pay_upfront_multiple".localized("\(intro.displayPrice)", "\(periodCount)", "\(period)", fallback: "\(intro.displayPrice) for first \(periodCount) \(period)s")
            } else {
                return "purchase.intro.pay_upfront_single".localized("\(intro.displayPrice)", "\(period)", fallback: "\(intro.displayPrice) for first \(period)")
            }
        default:
            return nil
        }
    }

    private var billingPeriod: String {
        switch product.type {
        case .autoRenewable:
            if let subscription = product.subscription {
                return periodText(subscription.subscriptionPeriod, style: .billing)
            }
            return "purchase.subscription.type".localized(fallback: "Subscription")
        case .nonConsumable:
            return "purchase.lifetime.type".localized(fallback: "Lifetime")
        case .consumable:
            return "purchase.consumable.type".localized(fallback: "Per use")
        default:
            return "purchase.unknown.type".localized(fallback: "Purchase")
        }
    }

    private func periodText(_ period: Product.SubscriptionPeriod, style: PeriodTextStyle = .billing) -> String {
        let unit = period.unit
        let value = period.value

        switch style {
        case .billing:
            switch unit {
            case .day:
                return value == 1
                    ? "purchase.period.billing.daily".localized(fallback: "Daily")
                    : "purchase.period.billing.day_multiple".localized("\(value)", fallback: "\(value)-day")
            case .week:
                return value == 1
                    ? "purchase.period.billing.weekly".localized(fallback: "Weekly")
                    : "purchase.period.billing.week_multiple".localized("\(value)", fallback: "\(value)-week")
            case .month:
                return value == 1
                    ? "purchase.period.billing.monthly".localized(fallback: "Monthly")
                    : "purchase.period.billing.month_multiple".localized("\(value)", fallback: "\(value)-month")
            case .year:
                return value == 1
                    ? "purchase.period.billing.annual".localized(fallback: "Annual")
                    : "purchase.period.billing.year_multiple".localized("\(value)", fallback: "\(value)-year")
            @unknown default:
                return "purchase.period.billing.periodic".localized(fallback: "Periodic")
            }
        case .descriptive:
            switch unit {
            case .day:
                return value == 1
                    ? "purchase.period.descriptive.daily".localized(fallback: "Daily")
                    : "purchase.period.descriptive.day_multiple".localized("\(value)", fallback: "Every \(value) days")
            case .week:
                return value == 1
                    ? "purchase.period.descriptive.weekly".localized(fallback: "Weekly")
                    : "purchase.period.descriptive.week_multiple".localized("\(value)", fallback: "Every \(value) weeks")
            case .month:
                return value == 1
                    ? "purchase.period.descriptive.monthly".localized(fallback: "Monthly")
                    : "purchase.period.descriptive.month_multiple".localized("\(value)", fallback: "Every \(value) months")
            case .year:
                return value == 1
                    ? "purchase.period.descriptive.yearly".localized(fallback: "Yearly")
                    : "purchase.period.descriptive.year_multiple".localized("\(value)", fallback: "Every \(value) years")
            @unknown default:
                return "purchase.period.descriptive.periodic".localized(fallback: "Periodic")
            }
        }
    }

    private enum PeriodTextStyle {
        case billing     // "Monthly", "Annual"
        case descriptive // "Every month", "Every year"
    }

    var body: some View {
        PurchaseOptionCardView(
            title: product.displayName,
            price: product.displayPrice,
            billingPeriod: billingPeriod,
            badge: badge,
            badgeColor: badgeColor,
            features: features,
            savings: savings,
            introductoryOffer: introductoryOfferDescription,
            description: productDescription,
            isSelected: isSelected,
            onSelect: onSelect
        )
    }
}

// MARK: - Shared UI Component

private struct PurchaseOptionCardView: View {
    let title: String
    let price: String
    let billingPeriod: String
    let badge: String?
    let badgeColor: Color?
    let features: [String]?
    let savings: String?
    let introductoryOffer: String?
    let description: String?
    let isSelected: Bool
    let onSelect: () -> Void

    var body: some View {
        Button(action: onSelect) {
            VStack(spacing: 0) {
                HStack(spacing: CardStyle.contentSpacing) {
                // Selection indicator
                ZStack {
                    Circle()
                        .stroke(isSelected ? Color.blue : Color.gray.opacity(0.3), lineWidth: CardStyle.selectionIndicatorStroke)
                        .frame(width: CardStyle.selectionIndicatorSize, height: CardStyle.selectionIndicatorSize)
                        .background(
                            Circle()
                                .fill(isSelected ? Color.blue.opacity(0.1) : Color.clear)
                        )

                    if isSelected {
                        Circle()
                            .fill(Color.blue)
                            .frame(width: CardStyle.selectionIndicatorFillSize, height: CardStyle.selectionIndicatorFillSize)
                    }
                }

                VStack(alignment: .leading, spacing: CardStyle.contentVerticalSpacing) {
                    HStack {
                        Text(title)
                            .font(.system(size: CardStyle.titleFontSize, weight: .semibold))
                            .foregroundColor(.primary)

                        if let badge = badge {
                            Spacer()
                            Text(badge)
                                .font(.system(size: CardStyle.badgeFontSize, weight: .bold))
                                .foregroundColor(.white)
                                .padding(.horizontal, CardStyle.badgeHorizontalPadding)
                                .padding(.vertical, CardStyle.badgeVerticalPadding)
                                .background(
                                    Capsule()
                                        .fill(badgeColor ?? (badge.lowercased().contains("popular") ? Color.orange : Color.blue))
                                )
                        }
                    }

                    // Display introductory offer prominently
                    if let introOffer = introductoryOffer {
                        HStack(spacing: 4) {
                            Image(systemName: "gift.fill")
                                .font(.system(size: CardStyle.featureFontSize - 1))
                                .foregroundColor(.green)
                            Text(introOffer)
                                .font(.system(size: CardStyle.featureFontSize + 1, weight: .semibold))
                                .foregroundColor(.green)
                        }
                        .padding(.horizontal, 8)
                        .padding(.vertical, 4)
                        .background(
                            RoundedRectangle(cornerRadius: 6)
                                .fill(Color.green.opacity(0.12))
                        )
                        .padding(.top, 2)
                    }

                    if let features = features, !features.isEmpty {
                        VStack(alignment: .leading, spacing: CardStyle.featuresSpacing) {
                            ForEach(features.prefix(2), id: \.self) { feature in
                                HStack(spacing: 4) {
                                    Text("•")
                                        .foregroundColor(.secondary)
                                        .font(.system(size: CardStyle.featureFontSize))
                                    Text(feature)
                                        .font(.system(size: CardStyle.featureFontSize))
                                        .foregroundColor(.secondary)
                                }
                            }
                        }
                        .padding(.top, CardStyle.featuresTopPadding)
                    }
                }

                Spacer()

                VStack(alignment: .trailing, spacing: CardStyle.featuresSpacing) {
                    Text(price)
                        .font(.system(size: CardStyle.priceFontSize, weight: .bold))
                        .foregroundColor(.primary)

                    if let savings = savings {
                        Text(savings)
                            .font(.system(size: CardStyle.savingsFontSize, weight: .semibold))
                            .foregroundColor(.green)
                    }

                    Text(billingPeriod)
                        .font(.system(size: CardStyle.billingPeriodFontSize, weight: .medium))
                        .foregroundColor(.secondary)
                }
            }
            .padding(.horizontal, CardStyle.horizontalPadding)
            .padding(.vertical, CardStyle.verticalPadding)

            if let description = description {
                Divider()
                    .padding(.horizontal, CardStyle.horizontalPadding)

                Text(description)
                    .font(.system(size: 11, weight: .regular))
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.leading)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .padding(.horizontal, CardStyle.horizontalPadding)
                    .padding(.vertical, 10)
            }
        }
        .background(
            RoundedRectangle(cornerRadius: CardStyle.cornerRadius)
                .fill(isSelected ? Color.blue.opacity(0.06) : Color.platformSecondaryBackground)
                .overlay(
                    RoundedRectangle(cornerRadius: CardStyle.cornerRadius)
                        .stroke(isSelected ? Color.blue.opacity(0.4) : Color.gray.opacity(0.15),
                               lineWidth: isSelected ? CardStyle.selectedStrokeWidth : CardStyle.unselectedStrokeWidth)
                )
            )
        }
        .platformButtonStyle()
        .scaleEffect(isSelected ? CardStyle.selectedScale : 1.0)
        .animation(.easeInOut(duration: CardStyle.animationDuration), value: isSelected)
        .platformHoverEffect()
    }
}

// MARK: - Preview

#if DEBUG
#Preview("Purchase Option Cards") {
    VStack(spacing: 20) {
        VStack(spacing: 8) {
            Text("PurchaseOptionCard Preview")
                .font(.title2.bold())

            Text("Different states and configurations")
                .font(.caption)
                .foregroundColor(.secondary)
        }

        VStack(spacing: 12) {
            // Standard monthly subscription with trial
            PurchaseOptionCardView(
                title: "Pro Monthly",
                price: "$9.99",
                billingPeriod: "Monthly",
                badge: nil,
                badgeColor: nil,
                features: ["Cloud sync", "Premium filters"],
                savings: nil,
                introductoryOffer: "7 days free trial",
                description: "Monthly subscription",
                isSelected: false,
                onSelect: { print("Selected: Pro Monthly") }
            )

            // Popular annual plan with savings and pay-as-you-go intro
            PurchaseOptionCardView(
                title: "Pro Annual",
                price: "$99.99",
                billingPeriod: "Yearly",
                badge: "Most Popular",
                badgeColor: .orange,
                features: ["Cloud sync", "Premium filters", "Priority support"],
                savings: "Save 30%",
                introductoryOffer: "$0.99 for first 3 months",
                description: "Annual subscription",
                isSelected: true,
                onSelect: { print("Selected: Pro Annual") }
            )

            // Lifetime purchase option (no intro offer)
            PurchaseOptionCardView(
                title: "Pro Lifetime",
                price: "$199.99",
                billingPeriod: "Lifetime",
                badge: "Best Value",
                badgeColor: .green,
                features: ["All features included", "Lifetime updates"],
                savings: nil,
                introductoryOffer: nil,
                description: "One-time purchase • Lifetime access",
                isSelected: false,
                onSelect: { print("Selected: Pro Lifetime") }
            )
        }

        VStack(spacing: 4) {
            Text("Features Demonstrated:")
                .font(.caption.bold())
                .foregroundColor(.secondary)

            VStack(alignment: .leading, spacing: 2) {
                Text("• Selection states (selected/unselected)")
                Text("• Introductory offers (free trial, discounted pricing)")
                Text("• Marketing badges (Most Popular, Best Value)")
                Text("• Savings indicators (Save 30%)")
                Text("• Feature lists with bullet points")
                Text("• Different product types (subscription, lifetime)")
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
            .font(.caption2)
            .foregroundColor(.secondary)
        }
        .padding(.top, 8)
    }
    .padding()
    .background(Color.platformBackground)
}
#endif
